using HanyCo.Infra.CodeGeneration.CodeGenerator.Bases;
using HanyCo.Infra.CodeGeneration.CodeGenerator.Interfaces;
using HanyCo.Infra.CodeGeneration.CodeGenerator.Models.Components;
using HanyCo.Infra.CodeGeneration.FormGenerator.Bases;
using HanyCo.Infra.CodeGeneration.Helpers;
using HanyCo.Infra.Markers;
using Library.CodeGeneration.Models;
using Library.Helpers.CodeGen;
using System.CodeDom;
using System.Globalization;

namespace HanyCo.Infra.CodeGeneration.CodeGenerator.Strageries.CodeDom;

[Worker]
internal static class CqrsCodeCompileUnitCreatorEngine
{
    private const string _AutoGeneratedFileHeader = "Created by HanyCo Infrastructure Code Generator with ♥";
    /// <summary>
    ///     Generators the code.
    /// </summary>
    /// <param name="model">The CQRS scafolding model.</param>
    /// <param name="cqrsType">Type of the CQRS.</param>
    /// <returns></returns>
    internal static IEnumerable<ICodeGeneratorUnit> Create(ICodeGenCqrsModel model)
    {
        var cqrsUnits = GenrateCqrsSegs(model);
        var dtoUnits = GenerateDtos(model);
        foreach (var (typeName, unit) in cqrsUnits)
        {
            yield return new CodeCompileUnitWrapper(unit, $"{typeName}", true);
        }

        if (model.Segregates.Any(x => x.HasPartialClass))
        {
            var partialUnits = GeneratPartialCqrsClasses(model);
            foreach (var (typeName, unit) in partialUnits)
            {
                yield return new CodeCompileUnitWrapper(unit, $"{typeName}", false);
            }
        }
        foreach (var (typeName, unit) in dtoUnits)
        {
            yield return new CodeCompileUnitWrapper(unit, $"{typeName}", true);
        }
    }

    internal static ICodeGeneratorUnit Create(CodeGenDto dto, string? nameSpace)
    {
        var (unit, typeName) = GenerateDto(dto, nameSpace);
        return new CodeCompileUnitWrapper(unit, typeName.Name);
    }
    private static IEnumerable<(string PropTypeName, string PropName, string BackingFieldName)> AddProps<TContainer>(in TContainer container,
        in CodeTypeDeclaration @class,
        in CodeNamespace classNameSpace,
        string? dtoNameSpace)
        where TContainer : IPropertyContainer
    {
        var result = new List<(string PropTypeName, string PropName, string BackingFieldName)>();
        foreach (var prop in container.Properties)
        {
            var nameSpaces = prop.Type.Namespaces;
            if (prop.Type is CodeGenDto && !dtoNameSpace.IsNullOrEmpty())
            {
                nameSpaces = nameSpaces.AddImmuted(dtoNameSpace);
            }

            _ = classNameSpace.UseNameSpace(nameSpaces);

            var propType = prop.Type.Name;
            if (prop.IsList)
            {
                propType = $"IEnumerable<{propType}>";
                _ = classNameSpace.UseNameSpace("System.Collections.Generic");
            }
            if (prop.IsNullable)
            {
                propType = $"{propType}?";
            }
            var propName = TypeMemberNameHelper.ToPropName(prop.Name);
            _ = @class.AddProperty(propType, propName, prop.Comment, setter: new(container is CodeGenDto, false));

            result.Add((propType, propName, TypeMemberNameHelper.ToFieldName(propName)));
        }

        return result.AsEnumerable();
    }

    private static CodeNamespace AddSegregateUsingNameSpaces(in ICodeGenCqrsModel model, in CodeCompileUnit unit)
        => unit.AddNewNameSpace(model.CqrsNameSpace);

    private static IEnumerable<(string TypeName, CodeCompileUnit Unit)> GenerateDtos(ICodeGenCqrsModel model)
    {
        var modelDtoNameSpace = model.DtoNameSpace;
        foreach (var dto in model.Dtos)
        {
            (var dtoUnit, var dtoClass) = GenerateDto(dto, modelDtoNameSpace);
            yield return (dtoClass.Name, dtoUnit);
        }
    }

    private static (CodeCompileUnit Unit, CodeTypeDeclaration Type) GenerateDto(CodeGenDto dto, string? modelDtoNameSpace = null)
    {
        var dtoNs = dto.Namespaces.Any()
                            ? dto.Namespaces.Count() == 1
                                ? dto.Namespaces.First()
                                : dto.Namespaces.ElementAt(1)
                            : modelDtoNameSpace is not null
                                ? modelDtoNameSpace
                                : string.Empty;
        var dtoUnit = new CodeCompileUnit();
        var dtoNameSpace = dtoUnit.AddNewNameSpace(dtoNs).UseNameSpace("System");
        var interfaceNameSpaces = dto.GetBaseTypes().Select(ns => ns.Namespaces).SelectAll();
        if (interfaceNameSpaces.Any())
        {
            foreach (var ns in interfaceNameSpaces)
            {
                if (ns is not null)
                {
                    _ = dtoNameSpace.UseNameSpace(ns);
                }
            }
        }

        var interfaceNames = dto.GetBaseTypes().Select(ns => ns.Name);
        var dtoClass = dtoNameSpace
            .AddNewClass(dto.Name, interfaceNames, true)
            .AddSummary(dto.Comment ?? $"The data transfer object of {dto.Name.Replace("DTO", "").Replace("Dto", "")}");
        _ = AddProps(dto, dtoClass, dtoNameSpace, dtoNs);
        return (dtoUnit, dtoClass);
    }

    private static CodeTypeDeclaration GeneratePartialSegregate<TSegregate>(in TSegregate segregate, string cqrsName, in CodeNamespace nameSpace)
        where TSegregate : ICodeGenCqrsSegregate
    {
        var segInterfaces = segregate.Interfaces;
        var interfaceNameSpaces = segInterfaces.Select(ns => ns.Namespaces).SelectAll();
        if (interfaceNameSpaces.Any())
        {
            foreach (var ns in interfaceNameSpaces)
            {
                if (ns is not null)
                {
                    _ = nameSpace.UseNameSpace(ns);
                }
            }
        }

        var className = $"{cqrsName}{segregate.Suffix}";
        var codeTypeDeclaration = nameSpace.AddNewClass(className, null, true);

        if (IsValidSegregatePartial(segregate, Partials.OnInitialize))
        {
            _ = codeTypeDeclaration.AddMethod(accessModifiers: MemberAttributes.ScopeMask, returnType: "partial void", name: "OnInitialize");
        }

        if (IsValidSegregatePartial(segregate, Partials.Handller))
        {
            _ = nameSpace.UseNameSpace("System.Threading.Tasks");
            _ = codeTypeDeclaration.AddMethod(
                    accessModifiers: MemberAttributes.Final | MemberAttributes.Public,
                    returnType: $"async Task<{cqrsName}Result>", name: "HandleAsync",
                    body: "            throw new System.NotImplementedException();",
                    arguments: new MethodArgument($"{cqrsName}Parameter", "parameter"));
        }

        return codeTypeDeclaration;
    }

    private static CodeTypeDeclaration GenerateSegregate<TSegregate>(
        in TSegregate segregate,
        string cqrsName,
        in CodeNamespace nameSpace,
        string? dtoNameSpace)
                where TSegregate : ICodeGenCqrsSegregate
    {
        var segInterfaces = segregate.GetIntefaces(cqrsName).Select(i => CodeGenType.New(i));
        var interfaceNameSpaces = segInterfaces.Select(ns => ns.Namespaces).SelectAll();
        foreach (var ns in interfaceNameSpaces)
        {
            if (!ns.IsNullOrEmpty())
            {
                _ = nameSpace.UseNameSpace(ns);
            }
        }

        var interfaceNames = segInterfaces.Select(ns => ns.Name);
        var className = $"{cqrsName}{segregate.Suffix}";
        var segClass = nameSpace.AddNewClass(className, interfaceNames, true);
        _ = segClass.AddSummary(segregate.Comment ?? $"The {segregate.Suffix.ToLower(CultureInfo.InvariantCulture)} of {cqrsName}");

        var ctorParams = new List<(string Type, string Name, string DataMemberName)>();
        ctorParams.AddRange(AddProps(segregate, segClass, nameSpace, dtoNameSpace));

        if (IsValidSegregatePartial(segregate, Partials.OnInitialize))
        {
            _ = segClass.AddConstructor(ctorParams, "            this.OnInitialize();", comment: $@"Initializes a new instance of the <see cref=""{className}""/> class.");
            _ = segClass.AddPartialMethod("OnInitialize");
        }
        else
        {
            _ = segClass.AddConstructor(ctorParams, comment: $@"Initializes a new instance of the <see cref=""{className}""/> class.");
        }

        return segClass;
    }

    private static IEnumerable<(string TypeName, CodeCompileUnit Unit)> GeneratPartialCqrsClasses(ICodeGenCqrsModel model)
    {
        foreach (var segregate in model.Segregates.Where(seg => seg.HasPartialClass))
        {
            var unit = new CodeCompileUnit();
            var parNameSpace = AddSegregateUsingNameSpaces(model, unit);
            var type = GeneratePartialSegregate(segregate, model.Name, parNameSpace);
            yield return (type.Name, unit);
        }
    }

    private static IEnumerable<(string TypeName, CodeCompileUnit Unit)> GenrateCqrsSegs(ICodeGenCqrsModel model)
    {
        foreach (var seg in model.Segregates)
        {
            var unit = new CodeCompileUnit().AddRegion(_AutoGeneratedFileHeader);
            var mainNameSpace = AddSegregateUsingNameSpaces(model, unit);
            var type = GenerateSegregate(seg, model.Name, mainNameSpace, model.DtoNameSpace);
            yield return (type.Name, unit);
        }
    }

    private static bool IsValidSegregatePartial<TSegregate>(in TSegregate segregate, in Partials partials)
        where TSegregate : ICodeGenCqrsSegregate
        => segregate.GetValidPartials().Contains(partials) && segregate.GetPartials().Contains(partials);
}
